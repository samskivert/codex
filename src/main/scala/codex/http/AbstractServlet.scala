//
// Codex - a multi-language code indexer and grokker
// http://github.com/samskivert/codex

package codex.http

import javax.servlet.http.HttpServlet
import javax.servlet.http.{HttpServletRequest => HSRequest, HttpServletResponse => HSResponse}
import scala.io.{Codec, Source}

import codex.Log

/** Defines a basic framework for simple servlet RPC.
  */
abstract class AbstractServlet (log :Log) extends HttpServlet {
  import HSResponse._

  /** An exception that can be thrown to abort processing and return an error. */
  case class HttpException (code :Int, message :String) extends Exception(message)

  /** Encapsulates the metadata with a service request. */
  trait Context {
    /** Any arguments supplied via path info. */
    def args :Seq[String]
    /** The http request. */
    def req :HSRequest
    /** The http response. */
    def rsp :HSResponse
    /** The body of the request, converted to a string. */
    def body :String
  }

  /** Defines the output type generated by this servlet. */
  type RES

  /** Performs the actual work of this servlet. */
  def process (ctx :Context) :RES

  /** Writes the output of `process` (if any) to the servlet response. */
  def writeOutput (rsp :HSResponse, result :RES) :Unit

  /** Returns true if access to this servlet is restricted to admins. Defaults to false. */
  def requireAdmin = false

  // various error throwing convenience methods
  protected def errBadRequest     (errmsg :String) = errorC(SC_BAD_REQUEST, errmsg)
  protected def errInternalError  (errmsg :String) = errorC(SC_INTERNAL_SERVER_ERROR, errmsg)
  protected def errForbidden      (errmsg :String) = errorC(SC_FORBIDDEN, errmsg)
  protected def errNotFound       (errmsg :String) = errorC(SC_NOT_FOUND, errmsg)
  protected def errorC (code :Int, errmsg :String) = throw new HttpException(code, errmsg)

  // route gets and posts to the same place
  override protected def doGet  (req :HSRequest, rsp :HSResponse) = process(req, rsp)
  override protected def doPost (req :HSRequest, rsp :HSResponse) = process(req, rsp)

  protected def process (req :HSRequest, rsp :HSResponse) {
    var ctx :Context = null
    try {
      ctx = mkContext(req, rsp)
      writeOutput(rsp, process(ctx))
    } catch {
      case he :HttpException => rsp.sendError(he.code, he.getMessage)
      case e :Throwable => {
        log.warning("Request failure", "url", req.getRequestURI, e)
        rsp.sendError(SC_INTERNAL_SERVER_ERROR);
      }
    }
  }

  protected class ContextImpl (
    val args :Seq[String],
    val req  :HSRequest,
    val rsp  :HSResponse) extends Context {
    lazy val body = Source.fromInputStream(req.getInputStream)(reqCodec).mkString

    private def reqCodec :Codec = req.getCharacterEncoding match {
      case null => Codec.UTF8
      case enc => enc
    }
  }

  protected def mkContext (req :HSRequest, rsp :HSResponse) :Context =
    new ContextImpl(parseArgs(req), req, rsp)

  protected def parseArgs (req :HSRequest) = req.getPathInfo match {
    case null | "" => Array[String]()
    case info => info.substring(1).split("/")
  }
}

